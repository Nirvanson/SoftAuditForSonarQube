% Großer Beleg in deutsch.
\documentclass[da,ngerman]{stthesis}

% Nur Titelseite in TUD-Layout, Rest in SWT-Layout
\usepackage[titlepageonly]{tudlayout}
\usepackage{longtable}
\usepackage{tabu}
\usepackage{multirow}
\usepackage{mathtools}
\usepackage{wasysym}
\usepackage{listings}

% Titel
\title{Erstellung eines (teil-)automatisierten \newline
Bewertungssystems für studentische \newline
Projekte im Softwarepraktikum}
% Author
\author{Jan Rucks}
% Datum Abgabedatum
\date{15.09.2017}
% Geburtstag
\birthday{07.11.1987}
% Geburtsort
\birthplace{Jena}
% Betreuer
\supervisor{Dr.-Ing. Birgit Demuth}

\hyphenation{Interpretations-spielraum}
\bibliographystyle{alpha}
\lstset{language=java}

\begin{document}
	\maketitle 
	\chapter*{Aufgabenstellung}
		schreib es auf
		
	\tableofcontents
  
	\chapter{Einleitung}
  		schreib es auf
    
	\chapter{Das Regelwerk}
		Eine der Säulen für ein (teil-)automatisiertes Bewertungssystem für das Softwarepraktikum ist zwangsläufig die Festlegung eines geeigneten Regelwerks, dass in SonarQube konfiguriert werden muss und als Basis für diverse Berechnungen zur Beurteilung der abgelieferten Softwarequalität dient. Zum einen fließt die Zahl der Regelverletzungen in mehrere Metriken ein und zum anderen sind einige dieser Regeln, oder Kombinationen mehrerer Regeln gleichzeitig Qualitätsindikatoren des für das Softwarepraktikum angepassten Code-Quality-Index. In diesem Kapitel soll zunächst auf die Notwendigkeit eines Regelwerks eingegangen, einige in der Industrie und Literatur vorgeschlagene Regelwerke vorgestellt und letztlich die getroffene Auswahl begründet und erklärt werden.
		\section{Warum Programmierregeln?}
			Grundsätzlich entsteht die Notwendigkeit für Programmierregeln und "`StyleGuides"' aus zwei für alle Programmiersprachen und Kontexte der Softwareentwicklung gleichen Gegebenheiten: 
			\begin{itemize}
				\item Die Möglichkeiten und Freiheiten die Programmiersprachen bieten gehen weit über das hinaus, was man tun sollte. Für jedes Problem gibt es mehrere Wege zum Ziel von denen viele aber massiv problematisch sind, weil sie beispielsweise sehr Fehleranfällig sind, gefährliche Sicherheitslücken aufweisen oder die Performanz der Software negativ beeinflussen. Die Idee hinter vielen Programmierregeln ist daher ungünstige Konstrukte zu vermeiden ("`Antipattern"') oder bewährte Varianten zu nutzen ("`Best Practices"')
				\item Die meiste Zeit verwendet der Programmierer auf das Lesen von Code, nicht für das eigentliche Schreiben \cite{CleanCode}. Dies gilt selbst für kleine allein bearbeitete Projekte da auch der selbst geschriebene Code immer wieder gelesen werden muss um ihn zu erweitern. Der Effekt verstärkt sich bei größeren Projekten die in Teams bewältigt werden da nun Code anderer Programmierer gelesen werden muss um den eigenen Code anbinden zu können und wird noch einmal stärker wenn es um die Wartung und Erweiterung von bestehenden Softwaresystemen geht. Daher ist eine gute Lesbarkeit des Codes notwendig um Effizient und Effektiv zu Programmieren. 
			\end{itemize}
			Beiden Sachverhalten lässt sich am geeignetsten durch ein Regelwerk begegnen, an dass sich alle am Projekt beteiligten Programmierer halten, um so möglichst vielen Fehlerquellen von vorne herein aus dem Weg zu gehen und möglichst gut lesbaren, konsistenten Code zu erhalten der leicht verstanden und damit erweitert werden kann.
			Leider gibt es kein allgemeingültiges Regelwerk das sich für beliebige Projekte anwenden lässt und somit für gute Code-Qualität sorgt. Recht einfach zu erkennen ist, dass zumindest für jede Programmiersprache ein eigenes Regelwerk notwendig ist, da jede Sprache ihre Eigenheiten und speziellen Stolperfallen besitzt. Doch auch innerhalb einer festgelegten Programmiersprache wie im Beispiel des Softwarepraktikums "`Java"' gibt es eine erstaunliche Vielfalt von zum Teil widersprüchlichen Regeln die auf verschiedenste Art und Weise zu Regelwerken zusammengefasst werden können. Dies lässt sich durch sehr verschiedene Anforderungsprofile der Projekte begründen, aber auch persönliche Vorlieben und Erfahrungen spielen eine große Rolle \cite{JavaQualityAssurance}. Im Folgenden einige konkrete Ursachen, die ein allgemeingültiges Regelwerk als nicht sinnvoll, wenn nicht sogar unmöglich erscheinen lassen:
			\begin{labeling}{\textbf{Erfahrung}}
				\item [\textbf{Relevanz}] Manche Regeln sind im Kontext eines speziellen Projekts einfach nicht Relevant. Wenn es sich um eine reine Desktop-PC-Anwendung ohne Internetzugriff handelt sind Regeln die auf sichere Verschlüsselung oder Schutz vor Angriffen abzielen einfach unwichtig. Auch Performanzbezogene Regeln spielen an vielen Stellen eine untergeordnete Rolle. 
				\item [\textbf{Zeit}] Programmiersprachen und Techniken verändern sich mit der Zeit. Es ist nur logisch, dass auch die zugehörigen Programmierregeln einer ständigen Überarbeitung und damit Veränderung unterliegen. Die Einführung von "`try-with-resources"' mit Java 1.7 ist ein Beispiel dafür. Gab es zuvor Regeln, die vorgaben geöffnete Resourcen in einem "`finally"'-Block freizugeben \cite{ElementsOfJavaStyle} wird nun von den meisten Autoren empfohlen das neue Sprach-Konstrukt zu verwenden, da so die geöffneten Resourcen automatisch geschlossen werden \cite{JavaCodingGuidelines}.
				\item [\textbf{Erfahrung}] Die Auswahl der Regeln hängt in beträchtlichem Maß von den persönlichen Erfahrungen der verantwortlichen Entwickler ab. Ein Entwickler, der in einem früheren Projekt massive Probleme mit dem "`casten"' von Variablen auf speziellere Datentypen hatte wird eher auf eine Regel bestehen, die genau das verbietet als jemand dem diese Probleme noch nicht begegnet sind, oder an Programmen gearbeitet hat in dem dies sogar notwendig war um die gewünschte Funktionalität umzusetzen \cite{JavaQualityAssurance}. Auch sollte das Regelwerk sich gerade im Lehrumfeld am geringen Erfahrungsstand der Studenten oder Schüler orientieren. Ein kleines, leicht zu verstehendes Regelwerk dass umgesetzt wird ist hier viel wirksamer, als ein möglichst Vollumfängliches, dass die Beteiligten überfordert und eher ignoriert wird \cite{CleanCodeImPraktikum}.
				  \item [\textbf{Vorlieben}] Insbesondere mit Blick auf die Lesbarkeit des Codes spielen die Vorlieben der Entscheider über das Regelwerk eine sehr große Rolle. Es lässt sich nicht festlegen, welcher Stil der beste ist. Wichtig ist allerdings, dass für das Projekt entsprechende Regeln möglichst genau definiert, und konsistent umgesetzt werden. 
				  \item [\textbf{Kontext}] Viele Regeln sind auch vom Projektkontext abhängig. Programme die in einem Kontext betrieben werden von dem Menschenleben abhängen erfordern beispielsweise eine sehr viel höhere Testabdeckung als ein Computerspiel. Eine Software die langfristig betrieben werden soll erfordert strengere Regeln für Lesbarkeit und Wartbarkeit als ein Prototyp.  
				  \item [\textbf{Ziel}] Neben dem Ziel ein praktikables Regelwerk für ein konkretes Projekt zu entwerfen kann das Ziel eines Regelwerks auch sein einen groben Rahmen für alle Projekte in einem Unternehmen zu schaffen wodurch die Regelauswahl sehr viel allgemeiner ausfallen wird. Ähnlich ist es wenn möglichst allgemeingültige Regeln für eine Veröffentlichung in Form eines Buches zusammen getragen werden, oder Studenten die Grundbegriffe von Softwarequalität vermittelt werden sollen.
			\end{labeling}
			Zusammenfassend lässt sich also feststellen, dass für eine hohe Softwarequalität ein für den konkreten Fall zusammengestelltes und angepasstes Regelwerk erforderlich ist, dass darüber hinaus gut und vollständig kommuniziert werden muss damit es auch Anwendung findet und die gewünschten Effekte bringt \cite{ImproveCodeQuality}.
		\section{Regelwerke}
			Im Rahmen der vorliegenden Arbeit wurde eine Reihe von Regelwerken ausgewertet um für die Anwendung im Softwarepraktikum eine Schnittmenge zu finden die möglichst wichtige und weit verbreitete Regeln beinhaltet. Im Folgenden sollen diese kurz vorgestellt und in Bezug auf die Relevanz für das Softwarepraktikum eingeordnet werden.
			\subsection{Clean Code von Robert Martin} \label{cleancodechapter}
				Robert Martin legt den Fokus seines Buches "`Clean Code"' auf das erstellen von gut lesbarem Code \cite{CleanCode}. Dies ist im Kontext dieser Arbeit nur ein Teilaspekt von Code-Qualität, aber speziell für die Lehre eine gute Grundlage um ein Bewusstsein für guten Code zu vermitteln. Dies wird darüber hinaus noch dadurch vereinfacht, dass es in mehreren Sprachen, darunter auch Deutsch, erschienen ist. \newline
				Neben einer ganzen Reihe von Techniken zum Schreiben von sauberem Code gibt der Autor auch viele Hinweise zur Durchführung von Refactorings, also der Transformation von chaotischem Code zu gut Lesbarem. Diese Techniken sind aus seiner Sicht essentiell, da es keinen Softwareentwickler gibt, der im ersten Wurf perfekten Code schreiben kann. Der Code wächst nach und nach, und viele Entscheidungen für die Platzierung von Code-Bausteinen stellen sich im Laufe der Entwicklung als ungünstig heraus. Die Verwendung der Variablen und Methoden ändert sich und die zuvor gewählten Namen passen nicht mehr. Methoden und Klassen wachsen über das sinnvolle Maß hinaus und müssen aufgeteilt werden. So wird es schnell erforderlich den gerade geschriebenen Code zu Überarbeiten um das gewachsene Chaos zu beseitigen und am Ende guten, sauberen Code abzuliefern. \newline
				Die für das Softwarepraktikum auszuwählenden Regeln sollen allerdings nicht den Prozess des Code Schreibens und der Überarbeitung betrachten sondern die statische Bewertung des Endergebnisses. Trotzdem finden sich in den von Martin aufgelisteten Regeln neben den nicht maschinell messbaren Prozessbezogenen Regeln viele "`Best Practices"' deren Einhaltung sich im Endergebnis messen lassen und damit potenziell Verwendung finden können. In Tabelle~\ref{cleancoderules} finden sich die 25 von insgesamt 66 Regeln aus "`Clean Code"' deren Einhaltung sich durch statische Code-Analyse messen lassen. \newline
				Zwei übergeordnete Prinzipien die Martin vorschlägt seien an dieser Stelle explizit erwähnt, da sie in keinem der anderen Regelwerke in dieser Form auftauchen:
				\begin{itemize}
					\item Extreme Kürze der Code-Bausteine, insbesondere Methoden  
					\item Vermeidung von Kommentaren durch selbsterklärenden Code
				\end{itemize}
				\begin{center}
					\tabulinesep=1.5mm
					\begin{longtabu}{|c|c|}
						\hline
  						\textbf{Regel} & \textbf{Kurzbeschreibung}\\
  						\hline
  						Auskommentierter Code & Code sollte nicht auskommentiert werden, Versionsverwaltung \\ & übernimmt Erhaltung von verworfenem Code \\
  						\hline
  						Zu viele Argumente & Maximal 3 Methodenparameter verwenden\\
  						\hline
  						Output-Argumente & Methodenparameter nicht überschreiben und als \\ & "`Ergebnisvariable"' benutzen \\
  						\hline
  						Flag-Argumente & Keine Booleschen Methodenparameter verwenden \\
  						\hline
  						Tote Funktionen & Nicht verwendete Methoden löschen \\
  						\hline
  						Übergangene Sicherungen & IDE-Warnungen, Exceptions und fehlschlagende Tests \\ & nicht Ignorieren \\
  						\hline 
  						Duplizierung & Duplizierte Code-Abschnitte in eigene Methoden auslagern \\ & und wiederverwenden \\
  						\hline
  						Falsche Vererbung & Keine Referenzen auf erbende Klassen in Basisklasse \\
  						\hline
  						Zu viele Informationen & Klassensignaturen (Anzahl öffentlicher Methoden) klein halten \\
  						\hline
  						Toter Code & Nicht verwendeten / erreichbaren Code entfernen \\
  						\hline
  						Vertikale Trennung & Lokale Variablen direkt über erster Verwendung, \\ & private Methoden direkt unter erster Verwendung deklarieren \\
  						\hline
  						Funktionsneid & Nur Variablen der eigenen Klasse manipulieren \\
  						\hline
  						Polymorphismus & Polymorphe Überschreibung von Methoden in Unterklassen \\ anstatt Switch & gegenüber Fallunterscheidung mit "`switch"' bevorzugen \\
  						\hline
  						Konventionen beachten & Im Team festgelegte Code-Konventionen einhalten \\
  						\hline
  						Magic Numbers & Konstante numerische Werte im Code durch sprechend \\ & benannte Konstanten ersetzen \\
  						\hline
  						Bedingungen einkapseln & Nicht triviale Bedingungen für Kontrollfluss-Anweisungen \\ & in eigene Methoden mit sprechendem Namen auslagern \\  
  						\hline
  						Negative Bedingungen & Keine negierten Bedingungen in Kontrollfluss-Anweisungen \\
  						\hline
  						Eine Aufgabe pro Funktion & Methoden sehr kurz halten (4 Anweisungen) \\
  						\hline
  						Grenzbedingungen kapseln & Öfter verwendete In-/Dekremente in Variablen ablegen \\
  						\hline
  						Transitive Navigation & Keine transitiven Methodenaufrufs-Ketten \\
  						\hline
  						Lange Importlisten & Bei Verwendung von mehr als 2 Klassen aus einem "`package"' \\ & "`Wildcard-Import"' benutzen \\
  						\hline
  						Konstanten-Vererbung & Konstanten nicht vererben, sondern statisch importieren \\
  						\hline
  						Enum statt Konstanten & Anstatt "`final static int"' Variablen lieber Enums verwenden \\
  						\hline
  						Kurze Namen & Nur "`Wegwerfvariablen"' (z.B. "`i"' in Schleife) dürfen kurz, \\ & nicht-sprechend benannt werden \\
  						\hline  
  						Unzureichende Tests & Alle Bedingungen durch Tests abdecken \\
  						\hline   
  						\caption{Regeln aus "`Clean Code"' von Robert Martin deren Einhaltung zumindest Teilweise durch statische Code-Analyse ermittelbar ist \cite{CleanCode}}
						\label{cleancoderules}
  					\end{longtabu}   
  				\end{center}
			\subsection{Solid Code von Marshall und Bruno}
				Das Buch "`Solid Code"' von Donis Marshall und John Bruno betrachtet umfassend den gesamten Prozess der Softwareentwicklung \cite{SolidCode}. \newline
				Dadurch ist der Aspekt Code-Qualität nur ein verhältnismäßig kleiner Teil des Buches neben Agilen Methoden, Entwurfs- und Design-Techniken, Performanz-Betrachtungen, Debugging und Prozessanalyse. Aus dem Kapitel zur defensiven Programmierung lassen sich allerdings einige, recht allgemeine Regeln ableiten die, obwohl im Buch "`C\#"' als Programmiersprache verwendet wird auch für das Softwarepraktikum mit "`Java"' Anwendung finden können. In Tabelle~\ref{solidcoderules} sind die 15 messbaren Regeln der 40 aus dem Kapitel zur Defensiven Programmierung Abgeleiteten aufgelistet, die nicht als "`C\#"'-spezifisch eingestuft werden.
				\begin{center}
					\tabulinesep=1.5mm
					\begin{longtabu}{|c|c|}
						\hline
  						\textbf{Regel} & \textbf{Kurzbeschreibung}\\
  						\hline
  						Softwaretest & Testabdeckung der Anweisungen von mindestens 90\% \\ 
  						\hline   
  						Namenskonventionen & Namenskonventionen für Team festlegen und umsetzen \\
  						\hline
  						Dokumentationskommentare & Mindestens alle öffentlichen Code-Elemente mit \\ & Dokumentationskommentaren (z.B. Javadoc) versehen \\
  						\hline
  						Klassen & Keine öffentlichen Variablen in Klassen verwenden \\
  						\hline
  						Zugriffsmodifizierer & Klassen und "`Class-Members"' so restriktiv wie möglich \\ & deklarieren (Sichtbarkeit, Modifizierbarkeit, ...) \\
  						\hline
  						Rückgabewerte & Rückgabewerte von Methoden immer überprüfen \\
  						\hline
  						Literale & Anstatt Literalen im Code sprechend benannte \\ &  Konstanten verwenden \\
  						\hline
  						Default Case & Jede "`switch"'-Anweisung sollte einen "`default"'-Case haben \\
  						\hline
  						Allgemeine Exceptions & Allgemeine "`Exceptions"' sollten nicht abgefangen werden \\
  						\hline
  						Fallunterscheidung & In "`catch"'-Blöcken sollte keine Fallunterscheidung \\ für Exceptions & Anhand des "`Exception"'-Typs erfolgen \\
  						\hline
  						Duplizierung & Duplizierte Code-Abschnitte in eigene Methoden auslagern \\ & und wiederverwenden \\
  						\hline
  						Schleifentypen & "`for"'-Schleifen gegenüber "`whlie"'-Schleifen bevorzugen \\
  						\hline
  						Freiwillige Blöcke & Optionale geschweifte Klammern immer verwenden \\ & (in If-/While-/For-Anweisungen) \\
  						\hline
  						Groß-/Kleinschreibung & Bezeichner dürfen nicht nur durch Groß-/Klein- \\ & Schreibung unterschieden werden \\
  						\hline
  						Switchvariable & Als "`switch"'-Variable nur Enums verwenden \\
  						\hline
  						\caption{Regeln aus dem Kapitel "`Defensive Programmierung"' im Buch "`Solid Code"' von Marshall und Bruno die auf Java übertragbar sind und deren Einhaltung zumindest Teilweise durch statische Code-Analyse ermittelbar ist \cite{SolidCode}}
						\label{solidcoderules}
  					\end{longtabu}   
  				\end{center}
			\subsection{Elements of Java Style von Vermeulen et al.}
				Das älteste der ausgewerteten Regelwerke ist das Buch "`The Elements of Java Style"' von Allan Vermeulen et al. \cite{ElementsOfJavaStyle} aus dem Jahr 2000. Dabei handelt es sich vorrangig um eine Unternehmensrichtline für das Schreiben von Java-Code bei "`Rogue Wave\textsuperscript{\textregistered} Software"', angereichert mit Regeln weiterer, unternehmensfremder Autoren. Trotz des Alters dieses Regelwerks sind nur sehr wenige Regeln als veraltet zu betrachten wie beispielsweise das Freigeben von Resourcen mittels "`finally"'-Block anstatt dem mittlerweile üblichen "`try-with-resources"' oder die händische Kapselung von Enumerationen in Klassen. \newline
				Das Buch konzentriert sich ausschließlich auf das Schreiben von möglichst verständlichem, wartbaren Java-Code. Trotzdem ist die Einhaltung vieler der angeführten Regeln nicht durch statische Codeanalyse messbar. In Tabelle~\ref{elementsrules} sind daher wiederum nur die Regeln aufgeführt die diese Bedingung erfüllen und darüber hinaus nicht veraltet sind. Dies sind 39 der 108 im Buch aufgeführten Regeln. \newline
				Allerdings kommt die im Softwarepraktikum irrelevante Sicht des Software-Lebenszyklus hinzu. So gibt es einige Regeln die sich auf die Erweiterung und Wartung von Software über mehrere Versionen hinweg beziehen. Darüber hinaus fällt auf, dass sehr großen Wert auf ausführliche Kommentierung des Codes gelegt wird obwohl selbsterklärender Code als vorrangiges Ziel genannt wird, was laut anderen Autoren eine Ausführliche Kommentierung überflüssig macht und sogar als potenzielles Problem eingestuft wird, da die Kommentare mit gepflegt werden müssen und veraltete und damit falsche Kommentare schlimmer sind als gar keine, da sie in die Irre führen können \cite{CleanCode}.
				\begin{center}
					\tabulinesep=1.5mm
					\begin{longtabu}{|c|c|}
						\hline
  						\textbf{Regel} & \textbf{Kurzbeschreibung}\\
  						\hline
  						Indent nested code & Konsistente Einrückung \\
  						\hline
  						Long lines & Maximale Zeilenlänge festlegen und einhalten \\
  						\hline
  						White space & Leerzeichen vor/nach Klammern und Operatoren, Leerzeilen \\ & zwischen Klassen, "`Class-Members"' und logischen Abschnitten \\
  						\hline 
  						No tabs & Nur Leerzeichen, keine Tabs verwenden \\
  						\hline
  						Long names & Keine zu langen Bezeichner verwenden \\
  						\hline
  						Names different & Bezeichner dürfen nicht nur durch Groß-/Klein- \\ in case & Schreibung unterschieden werden \\
  						\hline
  						Package name & Einzelnes, klein geschriebenes Wort für "`package"'-Namen \\
  						\hline
  						Class Name & Klassennamen in "`Upper CamelCase"' \\  							\hline
  						Method Name & Methodennamen in "`Lower CamelCase"' \\ 
  						\hline
  						Java Bean conventions & "`JavaBeans"' Namenskonventionen für \\ & "`getter"' und "`setter"' verwenden \\
  						\hline
  						Variable names & Variablennamen in "`Lower CamelCase"' \\ 
  						\hline
  						Qualify field variables & Klassenvariablen immer mit "`this"' referenzieren \\
  						\hline
  						Assign parameters & Methoden-/Konstruktor-Parameter die Klassenvariablen \\ to fields & zugewiesen werden sollten den gleichen Namen haben \\
  						\hline
  						Constant Name & Für Konstantennamen nur Großbuchstaben verwenden \\
  						\hline
  						Javadoc & Javadoc für alle Klassen, Interfaces, Methoden, Klassenvariablen \\
  						\hline
  						Package documentation & Für alle "`packages"' Kommentardatei schreiben \\
  						\hline
  						Javadoc style & Alle Javadoc-Kommentare nach SUN-Konventionen formatieren \\
  						\hline
  						Javadoc code tag & Bezeichner, Schlüsselwörter und Konstanten in \\ & Javadoc-Kommentaren mit "`code"'-Tag versehen \\
  						\hline 
  						Method Javadoc & Methodensignatur vollständig in Javadoc beschreiben \\
  						\hline
  						End line comments & Keine Kommentare an Zeilenende (außer Variablendeklaration) \\
  						\hline
  						Variable comment & Deklaration lokaler Variablen am Zeilenende kommentieren \\
  						\hline
  						Nested block comment & Bei tiefer Verschachtelung schließende Klammer \\ & mit Kommentar versehen \\
  						\hline
  						Fall through comment & Wenn "`switch-case"' nicht durch "`break"'-Anweisung \\ & abgeschlossen wird, durch "`fall-through"' Kommentar abschließen \\
  						\hline
  						Empty block comment & Leere Blöcke kommentieren \\
  						\hline
  						Small classes/methods & Klassen und Methoden möglichst klein halten \\
  						\hline
  						Private fields & Alle Klassenvariablen als privat deklarieren \\
  						\hline
  						Polymorphism & Polymorphe Methoden-Implementation anstatt \\ & "`instanceof"' verwenden \\
  						\hline
  						Duplicated blocks & Duplizierte Code-Abschnitte in eigene Methoden auslagern \\ & und wiederverwenden \\
  						\hline
  						Block statements & Optionale geschweifte Klammern immer verwenden \\ & (in If-/While-/For-Anweisungen) \\
  						\hline
  						Last case & Der letzte "`case"' in einem "`switch"' muss durch \\ & "`break"'-Anweisungen abgeschlossen werden \\
  						\hline
  						Compare Objects & Objekte mittels "`equals"'-Methode vergleichen \\
  						\hline
  						Construction final & In Konstruktoren nur Methoden aufrufen \\ & die als "`funal"' deklariert sind \\
  						\hline
  						Nested constructors & Allgemeine Konstruktoren in speziellen aufrufen \\
  						\hline
  						Runtime exceptions & "`Runtime-Exceptions"` nicht abfangen \\
  						\hline
  						Exception forwarding & Beim weiterleiten von "`Exceptions"' keine \\ & Informationen entfernen, lediglich anreichern \\
  						\hline   
  						Empty catch & Keine leeren "`catch"'-Blöcke verwenden \\
  						\hline
  						Object instances & Objektinstanzen erst erzeugen wenn sie gebraucht werden \\
  						\hline
  						Unnecessary objects & Keine unnötigen Objektinstanzen anlegen \\
  						\hline
  						Object factory & "'Factory"' zur Verwaltung von wiederverwendbaren \\ & Objektinstanzen nutzen \\
  						\hline
  						
  						\caption{Regeln aus "`The Elements of Java Style"' von Vermeulen et Al. die noch Gültigkeit haben und deren Einhaltung zumindest Teilweise durch statische Code-Analyse ermittelbar ist \cite{ElementsOfJavaStyle}}
						\label{elementsrules}
  					\end{longtabu}   
  				\end{center}
			\subsection{Code-Quality-Management von Simon et al.}
				Im Buch "`Code-Quality-Management"' beschreiben Frank Simon et Al. kein Regelwerk im eigentlichen Sinne \cite{CodeQualityManagement}. Stattdessen werden 52 Qualitätsindikatoren aufgeführt, die jeweils aus einem Problemmuster, vier Schwellwertstufen bezüglich der Häufigkeit des Problemmusters im untersuchten Programm im Vergleich zu Anderen in einer Datenbasis, einer Zuordnung zu einem oder mehreren Qualitätsmerkmalen und einer Beurteilung bezüglich Kosten und Unmittelbarkeit der Wirkung einer Behebung des Problemmusters bestehen. Diese Indikatoren werden benutzt um das zu untersuchende Programm einem Benchmark-Level zuzuordnen, der eine stark vereinfachte Qualitätsbeurteilung der Software darstellt. Dieses Verfahren wird als Code-Quality-Index bezeichnet und ist eine gute Alternative zur Bewertung der Code-Qualität im Vergleich zu den von Harry Sneed und anderen Autoren vorgeschlagenen Metriken \cite{SoftwareInZahlen}. \newline
				Der Code-Quality-Index wurde bereits im dieser Arbeit vorangegangenem Großen Beleg untersucht \cite{grosserBeleg} und soll in abgewandelter Form im zu erweiternden SonarQube-Plugin für das Bewertungssystem umgesetzt werden (siehe Kapitel \ref{indexchapter}). Als Grundlage wurden für das Regelwerk daher alle Problemmuster der 52 Indikatoren als Regeln mit aufgenommen, dargestellt in Tabelle~\ref{indexrules}. Eine Anpassung der Regeln für das Softwarepraktikum ist notwendig, da die Regeln und insbesondere die verwendeten Grenzwerte auf größere Projekte zugeschnitten sind und nicht auf die verhältnismäßig kleinen Studentenprojekte im Rahmen des Praktikums. 
				\begin{center}
					\tabulinesep=1.5mm
					\begin{longtabu}{|c|c|}
						\hline
  						\textbf{Regel} & \textbf{Kurzbeschreibung}\\
  						\hline
						Allgemeine Parameter & Casting von Methodenparametern vermeiden \\
						\hline
						Attributüberdeckung & Verwenden gleicher Variablennamen in Unterklassen vermeiden \\
						\hline
						Ausgeschlagenes Erbe & Methodenimplementierung von Oberklasse sollte von \\ - Implementierung & Mehrheit der Unterklassen nicht überschrieben werden \\
						\hline
						Ausgeschlagenes Erbe & Reduktion von Sichtbarkeiten in Unterklassen und \\ - Schnittstelle & Leer-Implementierung von Schnittstellen vermeiden \\
						\hline
						Datenkapselaufbruch & Keine öffentlichen Klassenvariablen verwenden \\
						\hline
						Duplizierter Code & Duplizierten Code vermeiden (>40 aufeinander folgende Zeilen) \\
						\hline
						Falsche Namenslänge & Bezeichner zwischen 2 und 50 Zeichen verwenden \\
						\hline
						Generationskonflikt & Erbende Klassen sollten höchstens die Hälfte der Oberklasse \\ & überschreiben ohne Oberklassenimplementierung zu nutzen \\
						\hline
						Gottdatei & Dateien sollten weniger als 2000 Zeilen enthalten \\
						\hline
						Gottklasse (Attribut) & Klassen sollten weniger als 50 Klassenvariablen deklarieren \\
						\hline
						Gottklasse (Methode) & Eine Klasse sollte weniger als 50 Methoden deklarieren \\
						\hline
						Gottmethode & Eine Methode sollte weniger als 200 Zeilen haben \\
						\hline
						Gottpaket & Ein "`package"' sollten höchstens 50 Klassen enthalten \\
						\hline
						Halbherzige Operationen & Klassen die equals() implementieren sollten auch \\ &  hashCode() implementieren \\
						\hline
						Heimliche Verwandschaft & Öffentliche Methoden einer Oberklasse sollten nicht nur \\ & von erbenden Klassen verwendet werden \\
						\hline
						Identitätsspaltung & Klassen sollten nicht den gleichen Namen haben \\ & oder sich nur durch Groß-/Kleinschreibung unterscheiden \\
						\hline
						Importchaos & Imports nicht doppelt, aus gleichem package, \\ & von java.lang oder als "`Wildcard"' \\
						\hline
						Importlüge & Unbenutzte Imports entfernen \\
						\hline
						Informelle & Öffentliche Methoden müssen formal kommentiert werden \\ Dokumentation & \\
						\hline
						Interface-Bypass & Implementation eines Methodeninterfaces sollten nicht \\ & direkt genutzt werden sondern über abstraktes Interface \\
						\hline
						Klässchen & Öffentliche Klassen sollten mindestens drei \\ & Methoden oder Klassenvariablen haben \\
						\hline
						Klasseninzest & Klassen dürfen keine Referenzen auf erbende Klassen haben \\
						\hline
						Konstantenregen & Namen von Konstanten sollten nur \\ &  einmal im System vorkommen \\
						\hline
						Labyrinthmethode & Die McCabe-Komplexität einer Methode sollte nicht >10 sein \\
						\hline
						Lange Parameterliste & Methoden sollten nicht mehr als 7 Parameter haben \\
						\hline
						Maskierende Datei & Dateiname sollte in enthaltener Klasse vollständig vorkommen \\
						\hline
						Nachlässige & (Dateizeilen - 2 * Kommentarzeilen) möglichst klein \\ Kommentierung & (Eine Kommentarzeile je Codezeile) \\
						\hline
						Namensfehler & Standard-Java-Namenskonventionen einhalten \\
						\hline
						Objektplacebo (Attribut) & Statische Attribute sollten nur statisch referenziert werden \\
						\hline
						Objectplacebo (Methode) & Statische Methoden sollten nur statisch referenziert werden \\
						\hline
						Paketchen & Pakete sollten mindestens drei öffentliche Klassen enthalten \\
						\hline
						Pakethierarchieaufbruch & Oberklassen sollten nicht in untergeordneten Paketen liegen, \\ & wenn erbende Klassen in übergeordneten Paketen liegen \\
						\hline
						Polymorphieplacebo & Statische Methoden der Oberklasse sollten nicht in \\ & erbenden Klassen überdeckt werden \\
						\hline
						Potenzielle Privatsphäre & Sichtbarkeiten von Variablen sollten so weit \\ (Attribut) & wie möglich eingeschränkt werden \\
\hline
						Potenzielle Privatsphäre & Methoden sollten nur protected deklariert werden wenn \\ (Methode) & sie eine Methode überschreiben oder überschrieben werden \\
						\hline
						Pränatale Kommunikation & In Konstruktoren nur "`finale"' Methoden aufrufen \\
						\hline
						Risikocode & Case-Anweisungen sollten mit break abgeschlossen werden, \\ & switch-Anweisungen sollten einen default-case enthalten \\ & und Catch-Anweisungen sollten nicht leer sein \\
						\hline
						Signaturähnliche Klassen & Höchstens 50\% identische Methodensignaturen zweier Klassen \\
						\hline
						Simulierte Polymorphie & Objekte sollten in einer Methode nicht auf mehrere \\ & Objekttypen überprüft werden (durch "`instanceof"') \\
						\hline
						Späte Abstraktion & Abstrakte Klassen sollten nicht von Nicht-Abstrakten erben \\
						\hline
						Tote Attribute & Ungenutzte private Variablen sollten entfernt werden \\
						\hline
						Tote Implementierung & Anweisungen die nie ausgeführt werden entfernen \\
						\hline
						Tote Methoden & Ungenutzte private Methoden sollten entfernt werden \\
						\hline
						Überbuchte Datei & Pro Datei nur eine übergeordnete öffentliche Klasse \\
						\hline
						Unfertiger Code & "`ToDo"' / "`FixMe"' / "`Hack"' -  sollte behoben werden \\
						\hline
						Unvollständige Vererbung & Eine nicht-statische Variable sollte nicht in mehr als 50\% \\ (Attribut) & der erbenden Klassen einer Oberklasse vorkommen \\
						\hline
						Unvollständige Vererbung & Eine Methodensignatur sollte nicht in mehr als 50\% \\ (Methode) & der erbenden Klassen einer Oberklasse vorkommen \\
						\hline
						Verbotene Dateiliebe & Zwei Dateien sollten nicht gegenseitig voneinander Abhängen \\
						\hline
						Verbotene Klassenliebe & Zwei nicht durch Vererbung zusammenhängende Klassen \\ & sollten nicht gegenseitig voneinander abhängen \\
						\hline
						Verbotene Methodenliebe & Zwei Methoden sollten sich nicht gegenseitig aufrufen \\
						\hline
						Verbotene Paketliebe & "`packages"' sollten nicht gegenseitig voneinander abhängen \\
						\hline
						Versteckte Konstantheit & Klassenvariablen die nach initialisierung nicht verändert \\ & werden sollten als "`final"' deklariert werden \\
  						\hline
  						\caption{Regeln aus "`Code-Quality-Management"' von Simon et Al. \cite{CodeQualityManagement}}
						\label{indexrules}
  					\end{longtabu}   
  				\end{center}
			\subsection{Java Coding Guidelines von Long et al.}
				Das Buch "`Java Coding Guidelines"' von Fred long et Al. konzentriert sich vornehmlich auf die Entwicklung sicherer und zuverlässiger Web-Anwendungen mit Java \cite{JavaCodingGuidelines}. Es basiert auf dem Buch "`The CERT Oracle Secure Coding Standard for Java"' von den gleichen Autoren \cite{SecureCodingStandard} und ist im Rahmen dieser Arbeit nur bedingt relevant, da eine ganze Reihe der vorgeschlagenen Regeln nicht die Java-Programmierung selbst betrachten sondern auf Sicherheitsaspekte abzielen, wie die Speicherung von Passwörtern und Ähnlichem. Trotzdem verbleiben 21 der 75 Regeln, die grundsätzliche Aspekte beinhalten und daher auch für das Softwarepraktikum betrachtet werden sollen (siehe Tabelle~\ref{guidelinesrules}). Diese Regeln sind ebenso für die Sicherheit und Zuverlässigkeit einer Web-Anwendung relevant, als auch unter dem allgemeineren Blickwinkel der Software-Qualität interessant. 
				\begin{center}
					\tabulinesep=1.5mm
					\begin{longtabu}{|c|c|}
						\hline
  						\textbf{Regel} & \textbf{Kurzbeschreibung}\\
  						\hline
  						Variable scope & Geltungsbereich von Variablen so klein wie möglich halten\\
						\hline
						Accessibility & Sichtbarkeit aller Konstrukte so gering wie möglich halten\\
						\hline
						Cyclic packages & Packages sollten nicht gegenseitig voneinander abhängen \\
						\hline
						Exception types & Möglichst eigene Exception-Typen verwenden \\
						\hline
						Garbage Collection & Möglichst kleine Objekte und \\ & keine expliziten Aufrufe des Garbage Collectors verwenden \\
						\hline
						Shadow identifiers & Bezeichner sollten nicht überdeckt werden \\
						\hline
						Declaration & Nur eine Variable pro Deklarationsanweisung \\
						\hline
						Constants & Literale als konstante Klassenvariablen deklarieren \\
						\hline
						Return empty & Leere Collections zurückgeben anstatt null \\
						\hline
						Try-with-resources & Wenn möglich try-with-resources verwenden \\
						\hline
						Visually misleading & Verwechselbare Zeichen nicht als alleinige Bezeichner oder \\ & einzigen Unterschied zwischen Bezeichnern verwenden \\
						\hline
						Overload variable & Methoden mit variablen Parameterlisten nicht überladen \\
						\hline
						Assignments & In Bedingungen keine Wertzuweisung vornehmen \\
						\hline
						Optional braces & Für alle if, for und while Anweisungen Klammern setzen \\
						\hline
						Empty conditionals & Keine leeren Kontrollflussanweisungen verwenden \\ & (nur Semikolon direkt hinter der Bedingung) \\
						\hline
						Break case & Case-Anweisungen immer mit break abschließen \\
						\hline
						Loop counters & Für Schleifen keine unereichbaren oder überspringbaren \\ & Abbruchbedingungen definieren \\
						\hline
						Clone & Alle clone() Methoden müssen super.clone() aufrufen \\
						\hline
						Unused & Ungenutzten Code, sowie Code ohne Effekte entfernen \\
						\hline
						Confusing overload & Überladene Methoden nicht nur in Reihenfolge der \\ & Parametertypen unterscheiden \\
						\hline
						Object equality & Objekte mit equals vergleichen \\
  						\hline
  						\caption{Regeln aus "`Java Coding Guidelines"' sich auf grundsätzliche Java-Programmierung beziehen und deren Einhaltung zumindest Teilweise durch statische Code-Analyse ermittelbar ist \cite{JavaCodingGuidelines}}
						\label{guidelinesrules}
  					\end{longtabu}   
  				\end{center}
			\subsection{Google Style Guide}
				Der "`Google Java Style Guide"' stellt eine vollständige Definition der von Google angesetzten Programmierregeln für die Sprache Java dar und wird bei allen für Google entwickelten Projekte in dieser Sprache angewendet  \cite{GoogleStyleGuide}. Ähnliche Regelwerke gibt es bei Google auch für viele andere gängige Programmiersprachen. Dieses Online verfügbare Dokument wird fortlaufend überarbeitet und weiterentwickelt. Im Rahmen dieser Arbeit wird der Stand von März 2017 betrachtet. Ein Anspruch des Regelwerks ist es, dass alle Regeln so klar sind, dass sie bereits in einer Entwicklungsumgebung erzwungen werden können. Regeln und Hinweise die Interpretationsspielraum lassen und subjektiv vom Betrachter abhängen wie zum Beispiel, das Vergeben sprechender Bezeichner, sind daher nicht aufgeführt. \newline
				Da es sich um eine Unternehmensrichtlinie handelt sind die Regeln auch auf eine spezielle Art der Formatierung festgelegt und nicht auf die allgemeine Forderung nach Konsistenz beschränkt. Für das Softwarepraktikum muss nicht zwangsläufig die gleiche Formatierung gewählt werden und einige Größenbeschränkungen sollten an die kleineren Studentenprojekte angepasst werden, aber der Style Guide liefert eine gute Zusammenfassung, an welchen Stellen die Formatierung einheitlich sein sollte und was in der Industriellen Praxis üblich ist. Außerdem ist es mit Abstand das aktuellste der ausgewerteten Regelwerke. Die 55 extrahierten Regeln sind in Tabelle~\ref{googlerules} aufgelistet.
				\begin{center}
					\tabulinesep=1.5mm
					\begin{longtabu}{|c|c|}
						\hline
  						\textbf{Regel} & \textbf{Kurzbeschreibung}\\
  						\hline
  												\hline
						Filename & Dateiname = Top-Level-Klassenname + Endung .java \\
						\hline
						File encoding & Datei-Encoding in UTF-8 \\
						\hline
						Whitespace & Nur Standardleerzeichen verwenden (keine Tabs) \\
						\hline
						Escape sequences & Spezielle Escape-Sequenzen anstatt Unicode-Repräsentation \\
						\hline
						Non-ASCII characters & Nicht-ASCII Zeichen nur innerhalb von String Literalen \\
						\hline
						Source file structure & Jede Datei soll folgende Struktur haben: \\ & Lizenz-Info + Package-Anweisung + Import-Anweisungen \\ &  + EINE Top-Level-Klasse \\
						\hline
						License information & Wenn benötigt am Dateianfang, als Block-Kommentar \\
						\hline
						Package Statement & Package-Anweisung immer in eine Zeile schreiben \\
						\hline
						No wildcard imports & Keine wildcard imports verwenden \\
						\hline
						No line-wrapping & Import-Anweisungen immer in eine Zeile schreiben \\
						\hline
						Ordering and spacing & Erst alle statischen imports als Block, dann alle anderen. \\ & Die Blöcke getrennt und alphabetisch sortiert \\
						\hline
						No static import& Statische Klassen nicht mit statischem import einbinden \\
						\hline
						One top-level class& Genau eine Top-Level Klasse je Datei \\
						\hline
						Class contents & Logische Ordnung in Klassen, \\ & Überladene  Methoden direkt aufeinanderfolgend \\
						\hline
						Optional Braces & Alle optionalen geschweiften Klammern setzen \\
						\hline
						Nonempty blocks & Nichtleere Blöcke mit öffnender Klammer an Zeilenende und \\ & schließender Klammer in eigener Zeile schreiben \\
						\hline
						Empty blocks & In Multi-Block-Anweisungen leere Blöcke mit Zeilenumbruch \\
						\hline
						Block indentation & Als Einrückung für Blockinhalt 2 Leerzeichen verwenden \\
						\hline
						Statements per line & Nur eine Anweisung pro Zeile schreiben \\
						\hline
						Column limit & Maximale Zeilenlänge = 100 Zeichen \\
						\hline
						Where to break & Anweisungen in mehreren Zeilen vermeiden \\
						\hline
						Indent continuation & Einrückung bei Zeilenumbruch innerhalb von Anweisung \\ & mindestens 4 Leerzeichen einrücken \\
						\hline
						Vertical whitespace & Leerzeilen zwischen "Class-Members" außer Variablen \\
						\hline
						Horizontal whitespace & Genau definiert, siehe Style-Guide  \\
						\hline
						Horizontal alignment & Horizontale Ausrichtung nicht verwenden \\
						\hline
						Grouping parentheses & Klammern zur Gruppierung komplexer Operationen verwenden \\
						\hline
						Enum classes & Enumwerte in einer Zeile, oder mit Zeilenumbruch nach Komma \\
						\hline
						Variable declarations & Nur eine Variable je Anweisung deklarieren \\
						\hline
						Arrays & Eckige Klammern immer am Typ und nicht am variablennamen \\
						\hline
						Switch Statements & Jedes Switch muss default case haben  \\
						\hline
						Annotations & Annotationen an Klassen, Methoden oder Konstruktoren \\ & hinter Javadoc, je eine Annotation pro Zeile \\
						\hline
						Comments & Kommentare genauso einrücken wie umgebender Code \\
						\hline
						Modifiers & Modifiers in fester Reihenfolge \\
						\hline
						Numeric Literals & Literale vom Typ long mit groß geschriebenem L \\
						\hline
						Zeichensatz & Nur ASCII Buchstaben und Zahlen in Namen verwenden \\
						\hline
						Package names & Package Namen komplett klein \\
						\hline
						Class names & Klassennamen in Upper CamelCase \\
						\hline
						Method names & Methodennamen in Lower CamelCase \\
						\hline
						Constant names & Konstantennamen komplett groß \\
						\hline
						Field names & Globale Variablennamen in Lower CamelCase \\
						\hline
						Parameter names & Parameternamen in Lower CamelCase \\
						\hline
						Variable names & Lokale Variablennamen in Lower CamelCase \\
						\hline
						Type names & Typvariablen sind entweder einzelner großer Buchstabe \\
						\hline
						Camel case & Abkürzungen in CamelCase nur mit erstem Buchstaben groß \\
						\hline
						@Override & Überschreibende Methoden mit @Override markieren \\
						\hline
						Caught exceptions & Keine leeren Catch-Anweisungen, außer in Tests \\
						\hline
						Static Members & Statische Methoden und variablen nur über Klassennamen \\ & referenzieren, nicht über Instanzen \\
						\hline
						Finalizers & finalize() Methode nicht überschreiben \\
						\hline
						General form & Start und Ende von Javadoc Kommentar in eigene Zeile \\
						\hline
						Paragraphs & Zwischen Absätzen in Javadoc eine Leerzeile nur mit * \\
						\hline
						Block tags & Tags in Javadoc-Kommentaren in fester Reihenfolge \\
						\hline
						Summary fragmnet & Erste Zeile eines Javadoc Kommentars ist Zusammenfassung \\ & ohne Subject abgeschlossen mit einem . \\
						\hline
						Where Javadoc & Javadoc an öffentlichen Klassen und "Class-Members" \\
						\hline
						Self-explanatory & Kein Javadoc an trivialen Methoden (getter / setter) \\
						\hline
						Overrides & Überschriebene Methoden brauchen kein Javadoc \\
						\hline
  						\caption{Regeln des "`Google Java Style Guide"'  \cite{GoogleStyleGuide}}
						\label{googlerules}
  					\end{longtabu}   
  				\end{center}
			\subsection{SoftAudit von Harry Sneed}
				Harry Sneed verwendet in seinem Software-Analyse-Werkzeug "`SoftAudit"' 80 Regeln um Fehlerberichte von Java-Programmen zu erstellen. Darüber hinaus geht die Anzahl der gefundenen Regelverletzungen in mehreren Metriken die auch im vorangegangenen Großen Beleg umgesetzt wurden \cite{grosserBeleg} mit in die Berechnung ein. Da es sich hierbei allerdings um eine Anwendung und keine Literatur-Quelle handelt sind die Regeln nicht detailliert erklärt \cite{SoftAuditDoku}. Im Gegensatz zu allen anderen Quellen nimmt Harry Sneed allerdings eine Abstufung der Regeln nach Fehlergewichtung vor. Er unterteilt die verwendeten Regeln in folgende vier Klassen:
				\begin{itemize}
					\item "`Security"' - Sicherheitskritisch 
					\item "`Deficiency"' - Schwerwiegendes Problem
					\item "`Problem"' - Möglicher Fehler
					\item "`Warning"' - Hinweise auf schlechten Stil
				\end{itemize}
				Diese finden sich in ähnlicher Form auch in der Zielplattform SonarQube wieder und bieten einen Anhaltspunkt für eine mögliche Klassifizierung der letztendlich ausgewählten Regeln. In Tabelle~\ref{softauditrules} sind die Regeln in der Originalformulierung zusammen mit der Einstufung aufgeführt.
				\begin{center}
					\tabulinesep=1.5mm
					\begin{longtabu}{|c|c|}
						\hline
  						\textbf{Einstufung} & \textbf{Regel}\\
  						\hline
						Problem & IO Operations must be contained be in a try block \\
						\hline
						Problem & Two Dimensional Arrays conflict with 1. Normal Form \\
						\hline
						Problem & Data Redefinitions conflict with 2. Normal Form \\
						\hline
						Problem & Data Casting should be avoided \\
						\hline
						Security & Constructor Methods should not be duplicated \\
						\hline
						Problem & Synchronization should be avoided \\
						\hline
						Problem & Method Invocation with array of objects should be in try block \\
						\hline
						Security & Return Value is not controlled after method invocation \\
						\hline
						Problem & Conditions should not contain an Assignment \\
						\hline
						Problem & Break is missing in switch Statement \\
						\hline
						Problem & Default is missing in switch Statement \\
						\hline
						Problem & Control logic exceeds maximum Nesting Level \\
						\hline
						Problem & More than one Statement on a Line \\
						\hline
						Security & Class Variables should never be declared public \\
						\hline
						Problem & instanceof should not be used \\
						\hline
						Problem & External Method Invocation should have a Class Reference \\
						\hline
						Security & Return Values should be checked \\
						\hline
						Security & Derived class is not declared as final \\
						\hline
						Problem & Class should not contain labels \\
						\hline
						Problem & Class attribute names should be qualified \\
						\hline
						Problem & equals should be used to compare objects \\
						\hline
						Problem & Interface definition should be in a separate source file \\
						\hline
						Security & Input Parameters of a Public Method should be checked \\
						\hline
						Problem & Returning a function may cause an endless loop \\
						\hline
						Problem & Number of catches does not match number of tries \\
						\hline
						Deficiency & Source module exceeds maximum size limit \\
						\hline
						Deficiency & Source module has more than maximum allowed Statements \\
						\hline
						Deficiency & Source module has more than maximum allowed Imports \\
						\hline
						Deficiency & Source module has more than maximum allowed Variables \\
						\hline
						Deficiency & Source module has more than maximum allowed Interfaces \\
						\hline
						Deficiency & Source module has more than maximum allowed Classes \\
						\hline
						Deficiency & Source module has more than maximum allowed Methods \\
						\hline
						Deficiency & Class exceeds maximum size limit \\
						\hline
						Deficiency & Method exceeds maximum size limit \\
						\hline
						Deficiency & Method has more than maximum allowed Parameters \\
						\hline
						Deficiency & Module references too many foreign Methods \\
						\hline
						Deficiency & Package should have a documentation header \\
						\hline
						Deficiency & Interface should have a documentation header \\
						\hline
						Deficiency & Class should have a documentation header \\
						\hline
						Deficiency & Method should have a documentation header \\
						\hline
						Deficiency & Compound Condition has more than two condition clauses \\
						\hline
						Deficiency & ? Operation should not be used in Expressions \\
						\hline
						Deficiency & Documentation header should include a code tag \\
						\hline
						Deficiency & Methods without Return value should be void \\
						\hline
						Deficiency & String Vectors should be avoided \\
						\hline
						Deficiency & Constants in procedural statements are forbidden \\
						\hline
						Deficiency & Literals in procedural statements are forbidden \\
						\hline
						Security & Embedded SQL functions should be avoided \\
						\hline
						Security & SQL Statement strings in code are vulnerable \\
						\hline
						Warning & Imports should proceed all other statements \\
						\hline
						Warning & Database Accesses are restricted to access classes \\
						\hline
						Warning & Nested Code should be indented by at least two columns \\
						\hline
						Warning & Code Line should not exceed maximum length of 120 Characters \\
						\hline
						Warning & Data Declaration should be followed by a Comment \\
						\hline
						Warning & Structure and union declarations should be proceeded by a comment \\
						\hline
						Warning & End Bracket should be followed by a Comment \\
						\hline
						Warning & Control Command should be on a separate line \\
						\hline
						Warning & Numeric constants should not start with a decimal point \\
						\hline
						Warning & Open Block Bracket should be on a separate line \\
						\hline
						Warning & Close Block Bracket should be on a separate line \\
						\hline
						Warning & Left Parenthesis should be proceeded by a space \\
						\hline
						Warning & Right Parenthesis should be followed by a space or Semicolon \\
						\hline
						Warning & Arithmetic Operator should be delimited by spaces \\
						\hline
						Warning & Logical Operator should be delimited by spaces \\
						\hline
						Warning & Else Clause should be on a seperate line \\
						\hline
						Warning & Method names should begin with a small letter \\
						\hline
						Warning & Method names should have at least four characters \\
						\hline
						Warning & Method/Class/interface names should not exceed 40 characters \\
						\hline
						Warning & Data names should be at least four characters long \\
						\hline
						Warning & Data names should begin with a capital letter \\
						\hline
						Warning & Data names should not exceed 36 characters \\
						\hline
						Warning & Class names should begin with a capital letter \\
						\hline
						Warning & Collection names should match class name \\
						\hline
						Warning & Package names should not exceed 8 characters \\
						\hline
						Warning & Package name should be given in source file \\
						\hline
						Warning & Multiple classes in a single source not allowed \\
						\hline
						Warning & Objects should never be compared with != null \\
						\hline
						Security & Objects should never be compared with a literal \\
						\hline
						Security & Classes should never be serializeable \\
						\hline
						Security & Classes should never be cloneable \\
  						\hline
  						\caption{Regeln für Java aus SoftAudit von Harry Sneed \cite{SoftAuditDoku}}
						\label{softauditrules}
  					\end{longtabu}   
  				\end{center}
			\subsection{Softwarepraktikum an der TU Dortmund}
				Von besonderem Interesse sind im Rahmen dieser Arbeit die Versuche von Doris Schmedding et Al. die an der Technischen Universität Dortmund Code-Qualität den Studenten vermitteln und im dortigen Softwarepraktikum messbar machen wollten \cite{CleanCodeImPraktikum}. Sie beschränkten sich dabei auf die Einhaltung von Programmierregeln, die sie auf Basis des in Kapitel~\ref{cleancodechapter} genannten Buches "`Clean Code"' von Robert Martin auswählten. Dabei wurde gezielt eine sehr kleine Anzahl von einfachen Regeln zusammengestellt um den zumeist unerfahrenen Praktikumsteilnehmern den Einstieg in die Thematik zu erleichtern und somit die Einhaltung der Regeln zu ermöglichen. In den folgenden Jahrgängen wurden die Regeln erprobt und zusammen mit einer kontinuierlichen Kommunikation der Regeln und der Bedeutung von Softwarequalität eine deutliche Qualitätsverbesserung der Praktikumsprojekte erzielt \cite{ImproveCodeQuality}. \newline
				Mit Blick auf das angestrebte automatisierte Bewertungssystem ist die getroffene Regelauswahl zu klein um angemessen zu Bewerten und auch nicht vollständig automatisierbar, allerdings können die Regeln (siehe Tabelle~\ref{soprarules}) als gut evaluierte Grundlage gesehen werden. Insbesondere die vorgenommene Anpassung der Grenzwerte, bezogen auf kleine studentische Projekte passen auch in diesem Kontext. \newline
				Aus den gewählten Regeln sticht die "`Gottklasse"' als sehr viel komplexer heraus und die Autoren merken an, dass dieses Konzept nur schwer zu vermitteln ist. Allerdings sind alle diese Klassen auch zu lang, sodass hier hauptsächlich ein einzelnes Problem in zwei Regeln verpackt wird und eine Suche nach besonders großen Klassen ausreichend ist.\newline \newline
				\begin{center}
					\tabulinesep=1.5mm
					\begin{longtabu}{|c|c|}
						\hline
  						\textbf{Regel} & \textbf{Kurzbeschreibung}\\
  						\hline
  						Naming Conventions & Für alle Bezeichner Java Namenskonventionen einhalten \\
  						\hline
						Meaningful Names & Alle Bezeichner mindestens 4 Zeichen lang und sprechend \\
						\hline
						Methodlength & Maximale Methodenlänge von 40 Zeilen nicht überschreiten \\
						\hline
						Parameterlist length & Maximal 5 Parameter in Methodensignatur \\
						\hline
						Cyclomatic Complexity & McCabe-Komplexität jeder Methode sollte höchstens 10 sein \\
						\hline
						Classlength & Klassen sollten höchstens 400 Zeilen lang sein \\
						\hline
						Dead Code & Ungenutzer Code sollte entfernt werden \\
						\hline
						Godclass  & Summe aller Methodenkomplexitäten (WMC) kleiner 48, \\ & Zugriffe auf Variablen anderer Klassen (AFTD) kleiner 6, \\ & Anteil zusammenhängende Methoden (TCC) größer 0,32 \\
						\hline
						Literals & Keine Verwendung von Literalen im Code - Konstanten \\
						\hline
						Deeply nested & Maximale Verschachtelungstiefe von If Anweisungen = 3 \\
						\hline
						Field declaration & Keine öffentlichen Klassenvariablen \\
  						\hline
  						\caption{Regeln die im Softwarepraktikum der TU-Dortmund von Vasileva und Schmedding verwendet wurden \cite{ImproveCodeQuality}}
						\label{soprarules}
  					\end{longtabu}   
  				\end{center}
		\section{Regelauswahl}
			Hinter allen ausgewerteten Regelwerken steht eine bestimmte Absicht und wie Anfangs bereits erwähnt kann keines davon allgemeingültig sein und ohne Anpassung für den neuen Kontext des automatisierten Bewertungssystems für das Softwarepraktikum übernommen werden. Selbst das thematisch sehr nah gelegene Regelwerk der TU Dortmund ist dafür nicht geeignet. Um eine Regelauswahl vorzunehmen wurde als Basis nach den Gemeinsamkeiten der verschiedenen Regelwerke gesucht und deren speziellere Absichten ausgeklammert um diese dann in Zusammenarbeit mit den Lehrstuhlmitarbeitern und in Abgleich zu den Möglichkeiten die SonarQube bietet zu einem stimmigen und praktikablen Regelwerk zu formen.
			\subsection{Der kleinste gemeinsame Nenner} \label{kleinernennerchapter}
			Trotz der enormen Bandbreite der gefundenen Regeln zeichnen sich doch eine ganze Reihe Gemeinsamkeiten ab. Zum einen gibt es ein paar spezielle zu vermeidende Konstrukte oder anzustrebende Pattern die immer wieder genannt werden wie beispielsweise die Verwendung der "`equals"'-Methode für den Objektvergleich oder das setzen freiwilliger Klammern. Daneben zeichnen sich auch einige Grundlegende übergeordnete Regeln ab, die in allen, oder zumindest einem Großteil der Quellen in diversen Ausprägungen enthalten sind. Dieser "`kleinste gemeinsame Nenner"' soll im Folgenden kurz dargestellt werden. \newline
				\begin{labeling}{\textbf{Formatierung}}
					\item [\textbf{Namen}] Bezeichner und Namen aller Art spielen eine entscheidende Rolle für die Verständ- lichkeit des Codes. Sie sollten üblichen Namenskonventionen folgen, nicht zu kurz oder lang sein und möglichst genau Beschreiben was sich hinter dem benannten Code-Konstrukt verbirgt. Bis auf den letzten Aspekt lässt sich dies einfach vermitteln, einhalten und messen.
					\item [\textbf{Formatierung}] Konsistente Formatierung des Codes, also Einrückung, Reihenfolgen, Klammern-Setzung und ähnliches trägt ebenso zur guten Lesbarkeit bei und sollte zumindest mit grundlegenden Aspekten berücksichtigt werden.  
					\item [\textbf{Duplikate}] Jegliche Duplikate im Code erschweren die Wartbarkeit einer Software extrem und sollten daher vermieden werden. 
					\item [\textbf{Größe}] Alle Code-Konstrukte sollten nicht zu groß werden. wenige große Klassen, Interfaces oder Methoden sind sehr viel schwerer zu verstehen, als etwas mehr Kleinere. Der Spielraum der angesetzten Grenzwerte ist dabei allerdings sehr groß und eine Orientierung ist am ehesten beim Softwarepraktikum in Dortmund sinnvoll, da dort ähnliche Projekte vermessen und gute Erfahrungen gemacht wurden.
					\item [\textbf{Komplexität}] Eng verknüpft mit der Größe der Code-Konstrukte ist deren Komplexität. Die Komplexität einer Methode wird üblicherweise durch die Zyklomatische Komplexität nach McCabe \cite{AComplexityMeasure} oder die Verschachtelungstiefe der Kontrollflussanweisungen beschrieben. Darüber hinaus können auch Verknüpfungen zu anderen Klassen oder Methoden mit einbezogen werden.
					\item [\textbf{Überflüssiges}] Alles Überflüssige sollte aus dem Code entfernt werden. So zum Beispiel Nichtssagende Kommentare, Nie ausgeführter Code oder ungenutzte Variablen und Methoden. 
					\item [\textbf{Literale}] Literale und insbesondere "`Magic Numbers"' (Numerische Literale im Code - Magische, da unerklärte Zahlen deren Ursprung sich zumeist nicht erschließt) erschweren das Lesen und Warten des Codes. Daher sollten alle Literale in gut benannten konstanten Variablen abgelegt werden.	
					\item [\textbf{Kommentare}]	Zumindest die öffentlichen Schnittstellen sollten durch Dokumentationskommentare beschrieben werden. Darüber hinaus ist selbstdokumentierender Code anzustreben und mit ausreichend Kommentaren zu unterstützen. Wichtig, aber nicht messbar ist dabei, dass die Kommentare korrekt und aktuell gehalten werden.			
				\end{labeling}
			\subsection{Regeln in SonarQube}
			SonarQube bietet eine sehr große Zahl feingranularer Regeln, die beliebig zu "`Quality Profiles"' Zusammengestellt werden können. Für viele dieser Regeln die auf bestimmten Grenzwerten (Wie zum Beispiel Methodengröße) oder Pattern (Wie zum Beispiel Namenskonventionen) beruhen ist es darüber hinaus möglich die Regeln den persönlichen Vorlieben oder Projektbedingungen entsprechend zu konfigurieren. Außerdem gibt es die Option die Regeln frei zu Klassifizieren. \newline
			SonarQube bietet dabei folgende Stufen \cite{SonarRuleSeverities}: 
			\begin{itemize}
				\item "`Blocker"' - Probleme die sehr wahrscheinlich zu ernsten Fehlern führen
				\item "`Critical"' - Probleme die möglicherweise zu ernsten Fehlern führen
				\item "`Major"' - Probleme die sehr wahrscheinlich zu leichten Fehlern führen 
				\item "`Minor"' - Probleme die möglicherweise zu leichten Fehlern führen 
				\item "`Info"' - Hinweise auf schlechten Stil
			\end{itemize}
			Die am Lehrstuhl für Softwaretechnik betriebene SonarQube-Installation in der Version 5.1.2 mit dem Java-Plugin in der Version 3.7.1 bietet 337 Regeln, neuere Versionen sogar noch deutlich mehr. Aufgrund der Fülle an kleinteiligen Regeln sei hier auf eine Auflistung verzichtet. Es wird allerdings schnell klar, dass die Aktivierung sämtlicher Regeln nicht sinnvoll sein kann, da ein solches Regelwerk nicht mehr zu überblicken ist und insbesondere Programmieranfängern nicht vermittelt werden kann. Außerdem schließen sich einige Regeln sogar gegenseitig aus. So gibt es Beispielsweise jeweils eine Regel für die zwei üblichen Varianten der Positionierung der geöffneten geschweiften Klammern von Code-Blöcken. Entweder am Ende der Zeile der zugehörigen Anweisung oder in einer eigenen Zeile. Offensichtlich kann hier nur eine Regel erfüllt werden. Neben den Regeln die sich den aus den verschiedenen Regelwerken extrahierten Kategorien zuordnen lassen gibt es hier vor allem eine große Anzahl von Regeln, die die Verwendung bestimmter Methoden oder ähnlichem verbieten. Da dies vor allem Spezialfälle sind die im Rahmen des Softwarepraktikums keine Relevanz haben können sie weitestgehend ignoriert werden. Stattdessen wurde sich darauf konzentriert die in der Literatur häufig genannten Regeln auf die von SonarQube bereitgestellten abzubilden, entsprechend den in Kapitel \ref{kleinernennerchapter} genannten Kategorien zu sortieren und so eine Vorauswahl zu generieren die immer noch 84 Regeln enthält, wobei allein elf Regeln auf die Anwendung von Namenskonventionen entfallen. Bis auf die Kategorie "`Duplikate"', die nur von einer Regel abgedeckt wird können allen anderen Kategorien mehrere Regeln zugeordnet werden. \newline
			\subsection{Die Auswahl für das Softwarepraktikum}
				
	\chapter{Der Code-Quality-Index für das Softwarepraktikum} \label{indexchapter}
  	% Notwendig für korrekte Nummerierung der Anlagen
  	\backmatter
  
  	\appendix
  	\bibliography{diplombib}
  
\end{document}
